(* ========================================================================= *)
(* HLRT-CDGR CORE FRAMEWORK - EXECUTABLE VERSION *)
(* Start here - run each section individually *)
(* ========================================================================= *)

ClearAll["Global`*"]

Print["🌌 HLRT-CDGR Framework - Step by Step Initialization"];

(* ========================================================================= *)
(* SECTION 1: BASIC CONSTANTS (RUN FIRST) *)
(* ========================================================================= *)

(* Physical Constants *)
c = 3*10^8;                    (* Speed of light, m/s *)
lP = 1.616*10^(-35);          (* Planck length, m *)
hbar = 1.055*10^(-34);        (* Reduced Planck constant, J·s *)
lambda = 1.24*10^(-13);       (* Lattice spacing, m *)
RE = 6.371*10^6;              (* Earth radius, m *)

(* HLRT Parameters *)
alpha = 0.0256;               (* EMF coupling constant *)
beta = 0.01;                  (* Spatial metric correction *)
betaFold = 1.16;              (* FTL enhancement factor *)
Lambda = 3.165*10^(-13);      (* Energy scale, J *)
Phi0 = 10^60;                 (* Lattice field energy density, J/m² *)

Print["✓ Constants loaded successfully"];

(* ========================================================================= *)
(* SECTION 2: CORE WAVE FUNCTIONS (RUN SECOND) *)
(* ========================================================================= *)

(* FTL Gravitational Wave Dispersion *)
omegaFTL[k_, h_] := k*c*betaFold*Sqrt[1 + h^2/Lambda];

(* FTL Velocity *)
vGW[k_, h_] := Module[{omega},
  omega = omegaFTL[k, h];
  If[k == 0, betaFold*c, omega/k]
];

(* Standard anisotropic dispersion (from your original code) *)
omega[kx_, ky_, h_, anisotropyScale_] := Module[{k, anisotropy},
  k = Sqrt[kx^2 + ky^2];
  anisotropy = anisotropyScale*(1 + 0.3*Tanh[2 - (kx*ky)/Sqrt[3]])*
               (1 + (beta*h^2)/Lambda);
  If[k == 0, 0, k*c*Sqrt[anisotropy]]
];

(* Phase velocity *)
vPhase[kx_, ky_, h_, anisotropyScale_] := Module[{k, om},
  k = Sqrt[kx^2 + ky^2];
  om = omega[kx, ky, h, anisotropyScale];
  If[k == 0, c, om/k]
];

Print["✓ Wave functions defined successfully"];

(* ========================================================================= *)
(* SECTION 3: TEST THE CORE FUNCTIONS *)
(* ========================================================================= *)

(* Test basic FTL prediction *)
testK = 10^7;
testH = 10^(-20);
vGWTest = vGW[testK, testH];
vGWRatio = vGWTest/c;

Print[""];
Print["🧪 BASIC FUNCTIONALITY TEST:"];
Print["FTL Velocity: ", N[vGWTest], " m/s"];
Print["Velocity Ratio: ", N[vGWRatio], " c"];
Print["Target: 1.16 c"];
Print["Match: ", If[Abs[vGWRatio - 1.16] < 0.1, "✓ GOOD", "⚠ NEEDS ADJUSTMENT"]];

(* Test time difference for 10m detection *)
distance = 10;
tLight = distance/c;
tGW = distance/vGWTest;
deltaT = tLight - tGW;

Print[""];
Print["⏱️ TIME DIFFERENCE ANALYSIS (10m):"];
Print["Light time: ", N[tLight*10^9], " ns"];
Print["GW time: ", N[tGW*10^9], " ns"];
Print["Difference: ", N[deltaT*10^9], " ns"];
Print["Target: ~4.6 ns"];
Print["Match: ", If[Abs[deltaT*10^9 - 4.6] < 2, "✓ GOOD", "⚠ NEEDS ADJUSTMENT"]];

Print[""];
Print["✅ Core functions working! Ready for next section.");
